# RabbitMQ 学习笔记(基于AMQP0-9-1协议)
# hello world
## 生产者 发送消息的应用
## exchanges 接收生产者的消息并将消息推送到符合规则的队列
## 队列 存储消息的缓冲器
## 消费者 接收处理消息的应用
# work queues
## Rabbit轮训分发任务到多个消费者（一个任务只被一个消费者消费）
默认情况下，RabbitMQ按照顺序将消息发送给每个消费者，
每个消费者会获取到相同数目的消息，
这种分发消息的方式被称为round-robin循环调度
## Consumer Acknowledgements（消费者确认）
### 为什么需要Consumer Acknowledgements

诸如RabbitMQ这种分布式消息队列，由于发送的方法或者消息不能确保接受者接收到并且已处理完成，
所以发布者和消费者都需要一个交付和处理确认机制

### 什么是Consumer Acknowledgements  
为了确保消息不丢失，RabbitMQ支持消息确认。当consumer收到消息并且已执行完成，consumer发回ack(nowledgement)通知RabbitMQ可以自由的删除该消息  
#### 自动消息确认  
在自动确认模式中，消息在发送后立即被认为成功传送。
##### 启用方式
autoAck设置为true（意为：fire-and-forget即发既忘，自动消息确认）  
##### 自动消息确认缺点
1. 如果将RabbitMQ将消息发送给消费者之后立即标记为删除，
执行某个任务可能需要耗费一定的时间，如果该任务只执行了一部分，worker宕机，将丢失这个正在执行的任务，
并且将丢失RabbitMQ已经分配给consumer的所有任务（尽管这些任务还没来得急执行，还在该consumer排队待执行），
自动消息确认应被视为不安全 ，并不适用于所有工作负载。 
2. 自动确认需要考虑的另外一种情况是消息过载。
手动确认模式通常与有界信道预取一起使用，该预取(prefetchCount)限制了信道上未完成（“进行中”）交付的数量。
但是，通过自动确认，根据定义没有这种限制。因此，消费者可能会被交付速度所淹没，
可能会积累内存中的积压并耗尽堆或使操作系统终止其进程。
某些客户端库将应用TCP反压（停止从套接字读取，直到未处理的交付积压超过某个限制）。
因此，仅建议能够以稳定的速度有效处理交付的消费者使用自动交钥匙模式。
##### 适用场景：
该模式折衷了更高的吞吐量（只要消费者可以跟上），
以降低交付和消费者处理的安全性。这种模式通常被称为“即发即忘”。
与手动确认模型不同，如果消费者的TCP连接或通道在成功交付之前关闭，
则服务器发送的消息将丢失，如果系统允许这种丢失，追求高吞吐量的时候可以使用
#### 手动消息确认：
关闭自动消息确认，进行手动消息确认方法的调用，通知Rabbit消息接收和处理情况
##### 优点
如果消费者宕机（可能情况：channel关闭，连接关闭，TCP连接丢失）没有发送ack回执，RabbitMQ了解到该消息没有被完全执行，将会重新排队。
如果此时还有其他consumer在线，将会快速的将该消息发送给其他consumer。这种方式将会确保消息不会丢失。 
##### 单次单个消息确认--启用方式
1. autoAck = false
2. 获取delivery tags
3. 调用channel.basicAck或者channel.basicNack或者channel.basicReject通知RabbitMQ消息接收情况
>注：  
当一个consumer（订阅）或者被注册时，消息将被RabbitMQ通过basic.deliver投递（推送），
该方法携带了一个delivery tag（交付标签），该标签可以在channel中唯一标识本次投递，
因此，每个交付标签的作用范围被限定在每个channel中  
交付标签是由客户端库提供的单调增长正整数，客户端库中确认交付的方法通过一个参数接收交付标签  
因为交付标签作用于每个channel，交付必须在被接收的channel中确认，
如果确认交付发生在其他channel中将抛出“未知投递标签”的错误，并且会关闭channel

##### 几种确认的区别
basic.ack用于肯定确认  
basic.nack用于否定确认（注意：这是AMQP 0-9-1的RabbitMQ扩展）  
basic.reject用于否定确认，但与basic.nack相比有一个限制  
basic.ack 意为通知RabbitMQ记录该消息已投递成功可以被遗弃，basic.reject有同样的效果，不同的地方在语义上：
该消息没有被成功处理，但是应该被RabbitMQ标记为删除

##### 单次多个消息确认--启用方式
设置multiple属性为true，basic.reject没有该属性（这是为什么basic.nack由RabbitMQ作为协议扩展引入的原因），可以对手动确认进行批处理以减少网络流量


##### 消极确认和重新排队
#问题：如果多个consumer绑定了同一个队列，并且RabbitMQ将同一个消息发给了多个consumer，多个consumer在同一时刻nack并且requeue=true，那么queue里是否会排队多个，怎么排的。官网文档里说，是根据delivery tag排的，delivery tag在channel中是唯一的。所以我觉得queue中即使有多个consumer对同一个消息requeue，那queue总重新排队的也只有一个，不知道对不对

**描述**：如果consumer无法处理消息，但是其他consumer可能可以进行处理，就需要对消息requeue（重新排队）让其他consumer对该消息进行处理。
当消息被重新排队时，broker会使用指定的delivery tag在其原来的位置重新排队，
但是如果多个consumer共享queue同时传递和确认（官方文档这里没看懂），那么该消息重排队的位置将更靠近队头。  
(due to concurrent deliveries and acknowledgements from other consumers when multiple consumers share a queue)  
**相关方法**：basic.nack 和 basic.reject  
**相关属性**：requeue （true重新排队，false不重新排队）；multiple（一次进行多条消息的拒绝或者重新排队，只有nack方法有该属性）  
#暂时没有理解下面的内容
> 注：重新排队的消息可以立即准备好重新发送，具体取决于它们在队列中的位置，
即具有活动消费者的通道使用的预取值。这意味着如果所有消费者因为因瞬态而无法处理交付而重新排队，他们将创建一个重新排队/重新发送循环。
就网络带宽和CPU资源而言，这种环路可能是昂贵的。消费者实施可以跟踪重新发送的数量并拒绝好消息（丢弃它们）或在延迟后安排重新排队。
## 消息预取设置(QoS)
### 为什么要使用消息预取设置
消息异步发送（推送）到客户端，手动确认本质也是异步的，因此channel中会有一个未确认消息的时间窗，实际生产中更倾向于限制此窗口的大小以避免
消费者端无限制无限缓冲造成的大量消息的堆积。
### 启用方式
basic.qos 值的定义：通道上允许的最大未确认消息的数量，一旦数量达到配置的计数，RabbitMQ将停止给该channel传递更多消息，
直到该channel至少一个未完成消息被确认  
>注：因为投递流程和手动确认完全异步，如果在已经投递一定数量的消息到channel中的情况下，
修改了QoS，那么在channel中会暂时出现消息数量>QoS的情况

## 消费者确认和预取对吞吐量的影响
确认模式和QoS预取值对消费者吞吐量有显着影响。通常，  
增加预取将提高向消费者传递消息的速率  
自动确认模式可以产生最佳的交付率  
但是，在这两种情况下，已传送但尚未处理的消息的数量也将增加，从而增加了消费者的RAM消耗。

应谨慎使用具有无限预取功能的自动确认模式或手动确认模式。
在没有确认的情况下消耗大量消息的消费者将导致他们所连接的节点上的内存消耗增长。
找到合适的预取值是试验和错误的问题，并且会因工作负载而异。
100到300范围内的值通常可提供最佳吞吐量，并且不会产生压倒性消费者的重大风险。
较高的价值往往会影响收益递减规律。

预取值1是最保守的。它将显着降低吞吐量，特别是在消费者连接延迟较高的环境中。
对于许多应用来说，更高的值是合适的和最佳的。

# 消息持久化
将队列（生产者和消费者）和消息都标记为持久
队列被定义后不能修改，如果已创建队列不能满足业务需求，需要重新创建一个新的队列来满足需求
